{"version":3,"file":"urql-vue.js","sources":["../src/useClient.ts","../src/useQuery.ts","../src/useMutation.ts","../src/useSubscription.ts","../src/useClientHandle.ts"],"sourcesContent":["import { App, getCurrentInstance, inject, provide } from 'vue';\nimport { Client, ClientOptions } from '@urql/core';\n\nexport function provideClient(opts: ClientOptions | Client) {\n  const client = opts instanceof Client ? opts : new Client(opts);\n  provide('$urql', client);\n  return client;\n}\n\nexport function install(app: App, opts: ClientOptions | Client) {\n  const client = opts instanceof Client ? opts : new Client(opts);\n  app.provide('$urql', client);\n}\n\nexport function useClient(): Client {\n  if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n    throw new Error(\n      'use* functions may only be called during the `setup()` or other lifecycle hooks.'\n    );\n  }\n\n  const client = inject('$urql') as Client;\n  if (process.env.NODE_ENV !== 'production' && !client) {\n    throw new Error(\n      'No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?'\n    );\n  }\n\n  return client;\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { DocumentNode } from 'graphql';\n\nimport { WatchStopHandle, Ref, ref, watchEffect, reactive, isRef } from 'vue';\n\nimport {\n  Source,\n  concat,\n  switchAll,\n  share,\n  fromValue,\n  makeSubject,\n  filter,\n  map,\n  pipe,\n  take,\n  publish,\n  onEnd,\n  onStart,\n  onPush,\n  toPromise,\n} from 'wonka';\n\nimport {\n  Client,\n  OperationResult,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  Operation,\n  createRequest,\n  GraphQLRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\n\ntype MaybeRef<T> = T | Ref<T>;\n\nexport interface UseQueryArgs<T = any, V = object> {\n  query: MaybeRef<TypedDocumentNode<T, V> | DocumentNode | string>;\n  variables?: MaybeRef<V>;\n  requestPolicy?: MaybeRef<RequestPolicy>;\n  context?: MaybeRef<Partial<OperationContext>>;\n  pause?: MaybeRef<boolean>;\n}\n\nexport type QueryPartialState<T = any, V = object> = Partial<\n  OperationResult<T, V>\n> & { fetching?: boolean };\n\nexport interface UseQueryState<T = any, V = object> {\n  fetching: Ref<boolean>;\n  stale: Ref<boolean>;\n  data: Ref<T | undefined>;\n  error: Ref<CombinedError | undefined>;\n  extensions: Ref<Record<string, any> | undefined>;\n  operation: Ref<Operation<T, V> | undefined>;\n  isPaused: Ref<boolean>;\n  resume(): void;\n  pause(): void;\n  executeQuery(opts?: Partial<OperationContext>): UseQueryResponse<T, V>;\n}\n\nexport type UseQueryResponse<T, V> = UseQueryState<T, V> &\n  PromiseLike<UseQueryState<T, V>>;\n\nconst watchOptions = {\n  flush: 'pre' as const,\n};\n\n/** Wonka Operator to replay the most recent value to sinks */\nfunction replayOne<T>(source: Source<T>): Source<T> {\n  let cached: undefined | T;\n\n  return concat([\n    pipe(\n      fromValue(cached!),\n      map(() => cached!),\n      filter(x => x !== undefined)\n    ),\n    pipe(\n      source,\n      onPush(value => {\n        cached = value;\n      }),\n      share\n    ),\n  ]);\n}\n\nexport function useQuery<T = any, V = object>(\n  args: UseQueryArgs<T, V>\n): UseQueryResponse<T, V> {\n  return callUseQuery(args);\n}\n\nexport function callUseQuery<T = any, V = object>(\n  _args: UseQueryArgs<T, V>,\n  client: Client = useClient(),\n  stops: WatchStopHandle[] = []\n): UseQueryResponse<T, V> {\n  const args = reactive(_args);\n\n  const data: Ref<T | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  const isPaused: Ref<boolean> = isRef(_args.pause)\n    ? _args.pause\n    : ref(!!_args.pause);\n\n  const request: Ref<GraphQLRequest<T, V>> = ref(\n    createRequest<T, V>(args.query, args.variables as V) as any\n  );\n\n  const source: Ref<Source<Source<any>>> = ref(null as any);\n  const next: Ref<\n    (query$: undefined | Source<OperationResult<T, V>>) => void\n  > = ref(null as any);\n\n  stops.push(\n    watchEffect(() => {\n      const newRequest = createRequest<T, V>(args.query, args.variables as any);\n      if (request.value.key !== newRequest.key) {\n        request.value = newRequest;\n      }\n    }, watchOptions)\n  );\n\n  const state: UseQueryState<T, V> = {\n    data,\n    stale,\n    error,\n    operation,\n    extensions,\n    fetching,\n    isPaused,\n    executeQuery(opts?: Partial<OperationContext>): UseQueryResponse<T, V> {\n      next.value(\n        client.executeQuery<T, V>(request.value, {\n          requestPolicy: args.requestPolicy,\n          ...args.context,\n          ...opts,\n        })\n      );\n\n      return response;\n    },\n    pause() {\n      isPaused.value = true;\n    },\n    resume() {\n      isPaused.value = false;\n    },\n  };\n\n  const getState = () => state;\n\n  stops.push(\n    watchEffect(\n      onInvalidate => {\n        const subject = makeSubject<Source<any>>();\n        source.value = pipe(subject.source, replayOne);\n        next.value = (value: undefined | Source<any>) => {\n          let onStartCalled = false;\n          const doOnStart = () => {\n            if (onStartCalled) return;\n            onStartCalled = true;\n            fetching.value = true;\n            stale.value = false;\n          };\n          const query$ = pipe(\n            value\n              ? pipe(\n                  value,\n                  onStart(doOnStart),\n                  onPush(res => {\n                    doOnStart();\n                    data.value = res.data;\n                    stale.value = !!res.stale;\n                    fetching.value = false;\n                    error.value = res.error;\n                    operation.value = res.operation;\n                    extensions.value = res.extensions;\n                  }),\n                  share\n                )\n              : fromValue(undefined),\n            onEnd(() => {\n              fetching.value = false;\n              stale.value = false;\n            })\n          );\n\n          subject.next(query$);\n        };\n\n        onInvalidate(\n          pipe(source.value, switchAll, map(getState), publish).unsubscribe\n        );\n      },\n      {\n        // NOTE: This part of the query pipeline is only initialised once and will need\n        // to do so synchronously\n        flush: 'sync',\n      }\n    )\n  );\n\n  stops.push(\n    watchEffect(() => {\n      next.value(\n        !isPaused.value\n          ? client.executeQuery<T, V>(request.value, {\n              requestPolicy: args.requestPolicy,\n              ...args.context,\n            })\n          : undefined\n      );\n    }, watchOptions)\n  );\n\n  const response: UseQueryResponse<T, V> = {\n    ...state,\n    then(onFulfilled, onRejected) {\n      return (data.value\n        ? Promise.resolve(state)\n        : pipe(source.value, switchAll, map(getState), take(1), toPromise)\n      ).then(onFulfilled, onRejected);\n    },\n  };\n\n  return response;\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { ref, Ref } from 'vue';\nimport { DocumentNode } from 'graphql';\n\nimport {\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\n\nexport interface UseMutationState<T, V> {\n  fetching: Ref<boolean>;\n  stale: Ref<boolean>;\n  data: Ref<T | undefined>;\n  error: Ref<CombinedError | undefined>;\n  extensions: Ref<Record<string, any> | undefined>;\n  operation: Ref<Operation<T, V> | undefined>;\n  executeMutation: (\n    variables: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport type UseMutationResponse<T, V> = UseMutationState<T, V>;\n\nexport function useMutation<T = any, V = any>(\n  query: TypedDocumentNode<T, V> | DocumentNode | string\n): UseMutationResponse<T, V> {\n  return callUseMutation(query);\n}\n\nexport function callUseMutation<T = any, V = any>(\n  query: TypedDocumentNode<T, V> | DocumentNode | string,\n  client: Client = useClient()\n): UseMutationResponse<T, V> {\n  const data: Ref<T | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  return {\n    data,\n    stale,\n    fetching,\n    error,\n    operation,\n    extensions,\n    executeMutation(\n      variables: V,\n      context?: Partial<OperationContext>\n    ): Promise<OperationResult<T, V>> {\n      fetching.value = true;\n      return client\n        .mutation(query, variables as any, context)\n        .toPromise()\n        .then((res: OperationResult) => {\n          data.value = res.data;\n          stale.value = !!res.stale;\n          fetching.value = false;\n          error.value = res.error;\n          operation.value = res.operation;\n          extensions.value = res.extensions;\n          return res;\n        });\n    },\n  };\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { DocumentNode } from 'graphql';\nimport { Source, pipe, publish, share, onStart, onPush, onEnd } from 'wonka';\n\nimport { WatchStopHandle, Ref, ref, watchEffect, reactive, isRef } from 'vue';\n\nimport {\n  Client,\n  OperationResult,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n  createRequest,\n  GraphQLRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\n\ntype MaybeRef<T> = T | Ref<T>;\n\nexport interface UseSubscriptionArgs<T = any, V = object> {\n  query: MaybeRef<TypedDocumentNode<T, V> | DocumentNode | string>;\n  variables?: MaybeRef<V>;\n  pause?: MaybeRef<boolean>;\n  context?: MaybeRef<Partial<OperationContext>>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\nexport type SubscriptionHandlerArg<T, R> = MaybeRef<SubscriptionHandler<T, R>>;\n\nexport interface UseSubscriptionState<T = any, R = T, V = object> {\n  fetching: Ref<boolean>;\n  stale: Ref<boolean>;\n  data: Ref<R | undefined>;\n  error: Ref<CombinedError | undefined>;\n  extensions: Ref<Record<string, any> | undefined>;\n  operation: Ref<Operation<T, V> | undefined>;\n  isPaused: Ref<boolean>;\n  resume(): void;\n  pause(): void;\n  executeSubscription(opts?: Partial<OperationContext>): void;\n}\n\nexport type UseSubscriptionResponse<\n  T = any,\n  R = T,\n  V = object\n> = UseSubscriptionState<T, R, V>;\n\nconst watchOptions = {\n  flush: 'pre' as const,\n};\n\nexport function useSubscription<T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<T, V>,\n  handler?: SubscriptionHandlerArg<T, R>\n): UseSubscriptionResponse<T, R, V> {\n  return callUseSubscription(args, handler);\n}\n\nexport function callUseSubscription<T = any, R = T, V = object>(\n  _args: UseSubscriptionArgs<T, V>,\n  handler?: SubscriptionHandlerArg<T, R>,\n  client: Client = useClient(),\n  stops: WatchStopHandle[] = []\n): UseSubscriptionResponse<T, R, V> {\n  const args = reactive(_args);\n\n  const data: Ref<R | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  const scanHandler: Ref<SubscriptionHandler<T, R> | undefined> = ref(handler);\n\n  const isPaused: Ref<boolean> = isRef(_args.pause)\n    ? _args.pause\n    : ref(!!_args.pause);\n\n  const request: Ref<GraphQLRequest<T, V>> = ref(\n    createRequest<T, V>(args.query, args.variables as V) as any\n  );\n\n  const source: Ref<Source<OperationResult<T, V>> | undefined> = ref();\n\n  stops.push(\n    watchEffect(() => {\n      const newRequest = createRequest<T, V>(args.query, args.variables as any);\n      if (request.value.key !== newRequest.key) {\n        request.value = newRequest;\n      }\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(() => {\n      if (!isPaused.value) {\n        source.value = pipe(\n          client.executeSubscription<T, V>(request.value, {\n            ...args.context,\n          }),\n          share\n        );\n      } else {\n        source.value = undefined;\n      }\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(onInvalidate => {\n      if (source.value) {\n        onInvalidate(\n          pipe(\n            source.value,\n            onStart(() => {\n              fetching.value = true;\n            }),\n            onEnd(() => {\n              fetching.value = false;\n            }),\n            onPush(result => {\n              fetching.value = true;\n              (data.value =\n                result.data !== undefined\n                  ? typeof scanHandler.value === 'function'\n                    ? scanHandler.value(data.value as any, result.data!)\n                    : result.data\n                  : (result.data as any)),\n                (error.value = result.error);\n              extensions.value = result.extensions;\n              stale.value = !!result.stale;\n              operation.value = result.operation;\n            }),\n            publish\n          ).unsubscribe\n        );\n      }\n    }, watchOptions)\n  );\n\n  const state: UseSubscriptionState<T, R, V> = {\n    data,\n    stale,\n    error,\n    operation,\n    extensions,\n    fetching,\n    isPaused,\n    executeSubscription(\n      opts?: Partial<OperationContext>\n    ): UseSubscriptionState<T, R, V> {\n      source.value = pipe(\n        client.executeSubscription<T, V>(request.value, {\n          ...args.context,\n          ...opts,\n        }),\n        share\n      );\n\n      return state;\n    },\n    pause() {\n      isPaused.value = true;\n    },\n    resume() {\n      isPaused.value = false;\n    },\n  };\n\n  return state;\n}\n","import { DocumentNode } from 'graphql';\nimport { Client, TypedDocumentNode } from '@urql/core';\nimport {\n  WatchStopHandle,\n  getCurrentInstance,\n  onMounted,\n  onBeforeUnmount,\n} from 'vue';\n\nimport { useClient } from './useClient';\n\nimport { callUseQuery, UseQueryArgs, UseQueryResponse } from './useQuery';\n\nimport { callUseMutation, UseMutationResponse } from './useMutation';\n\nimport {\n  callUseSubscription,\n  UseSubscriptionArgs,\n  SubscriptionHandlerArg,\n  UseSubscriptionResponse,\n} from './useSubscription';\n\nexport interface ClientHandle {\n  client: Client;\n\n  useQuery<T = any, V = object>(\n    args: UseQueryArgs<T, V>\n  ): UseQueryResponse<T, V>;\n\n  useSubscription<T = any, R = T, V = object>(\n    args: UseSubscriptionArgs<T, V>,\n    handler?: SubscriptionHandlerArg<T, R>\n  ): UseSubscriptionResponse<T, R, V>;\n\n  useMutation<T = any, V = any>(\n    query: TypedDocumentNode<T, V> | DocumentNode | string\n  ): UseMutationResponse<T, V>;\n}\n\nexport function useClientHandle(): ClientHandle {\n  const client = useClient();\n  const stops: WatchStopHandle[] = [];\n\n  onBeforeUnmount(() => {\n    let stop: WatchStopHandle | void;\n    while ((stop = stops.shift())) stop();\n  });\n\n  const handle: ClientHandle = {\n    client,\n\n    useQuery<T = any, V = object>(\n      args: UseQueryArgs<T, V>\n    ): UseQueryResponse<T, V> {\n      return callUseQuery(args, client, stops);\n    },\n\n    useSubscription<T = any, R = T, V = object>(\n      args: UseSubscriptionArgs<T, V>,\n      handler?: SubscriptionHandlerArg<T, R>\n    ): UseSubscriptionResponse<T, R, V> {\n      return callUseSubscription(args, handler, client, stops);\n    },\n\n    useMutation<T = any, V = any>(\n      query: TypedDocumentNode<T, V> | DocumentNode | string\n    ): UseMutationResponse<T, V> {\n      return callUseMutation(query, client);\n    },\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    onMounted(() => {\n      Object.assign(handle, {\n        useQuery<T = any, V = object>(\n          args: UseQueryArgs<T, V>\n        ): UseQueryResponse<T, V> {\n          if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n            throw new Error(\n              '`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.'\n            );\n          }\n\n          return callUseQuery(args, client, stops);\n        },\n\n        useSubscription<T = any, R = T, V = object>(\n          args: UseSubscriptionArgs<T, V>,\n          handler?: SubscriptionHandlerArg<T, R>\n        ): UseSubscriptionResponse<T, R, V> {\n          if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n            throw new Error(\n              '`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.'\n            );\n          }\n\n          return callUseSubscription(args, handler, client, stops);\n        },\n      });\n    });\n  }\n\n  return handle;\n}\n"],"names":["process","env","client","flush","replayOne","const","_args","ref","fetching","error","operation","extensions","isPaused","vue","request","source","next","stops","createRequest","executeQuery","context","args","value","cached","map","stale","data","onInvalidate","undefined","callUseMutation","scanHandler","key","result","share","publish","pause","resume","provide","opts","install","handle","useClient","useSubscription","onMounted","NODE_ENV","useQuery","query"],"mappings":";;;;;;;;;;;;;;;;;;;;AAYC;;IAGKA,QAAQC;;;;uBAMNC;;;;;;;ECgDNC,OAAOD;;;;SAIAE;;;AAiCPC,sBAAgCC;WACDC,MAAzBC;IAA6BN;;iBAC7BO;;;MACAC;MACAC;MAEAC,IAAQC;MAIRC;MAIAC;MACAC;EAINC;YAEuBC,2BAAoCL,QAAvBP;;UACrBO;MACTC,IAAOD;;;;;;;;;;IAaXM;;;cAIcC;;;;uBAQKC;;;;;;;;;;;;IAafN,OAAOO;;;;cAvFkB;;;QAKzBC;UAFFR,EAPUS,KAAd;;SAOIT;;;;;;;QA0FMP;;;;QAqBEA,EAASc,SAAQ;QACjBG,EAAMH,SAAQ;;gBAZSI;QACjBD;QACAjB,WAAA;;QAEAE;QACAC;QAXHc;mBAsBP;;;oBAI8BD;;;;IAxCtCG;;WAyDmB;;;;;0BAUPC;;;;;;;SCpMLC;;;AAYPxB;;;;;;;;;;;;;;;;;8BAsB8BK;;;QAR1BgB;;;;;UCTeJ;;;;;;;;;;;AAwBnBjB;WAEiB,MAAXyB;;;iBAEAlB;QAAoC;;MAIpCE,IAAOD;MAIPE;EAENE;YAEuBC;;YACDa;MAChBjB,IAAAD;;UAHOA;EAQbI;;SAGaK;;;;;;;;QA0BKA,QACJU,EAAMC,8BACiBX,oBAAnBD;;QAMDC;;;IAZLd,OAASc;QANbP;UAGqBmB;QAHrB1B;;;;UA4BqCc;;;;YAI3CZ;;;;;MAOEK;;;IAUFoB;eACWb;;IAEXc;cACUxB;;;;;;;;;;;;;;;;;;;wBHrKZyB,uBAAiBnC;UACjBoC;;SAGcC;;;0BIqCb;MAEKC,IAAuBC;;;;IAS3BC;;;;;;;;;IAeAC;;;0BAKsBC;;;;;MASlBF;;kBAKU,SAAAG;;;;;;;;;;;;;;;;;;sBFjDhBxC,qBAA+ByC;yBACIA;;;;;;;0BC4BnCzC;;;;;;"}